package com.example.fujitsu.dagger2studyproject.di;

import com.example.fujitsu.dagger2studyproject.DatabaseHelper;
import com.example.fujitsu.dagger2studyproject.MainActivity;
import com.example.fujitsu.dagger2studyproject.NetworkUtils;

import dagger.Component;

/**При компиляции проекта, даггер найдет этот интерфейс по аннотации @Component и сгенерирует класс
 *  DaggerAppComponent, которые реализует этот интерфейс. Это и будет класс компонента.Все что от
 *  нас требуется - наполнить интерфейс методами. Этим мы дадим понять компоненту, какие объекты
 *  он должен уметь нам возвращать. А при сборе проекта даггер уже сам их реализует в сгенерированном
 *  классе компонента.Компонент может возвращать нам объекты двумя способами. Первый - это обычные
 *  get-методы. Т.е. мы просто вызываем метод, который вернет нам объект. Второй способ интереснее,
 *  это inject-методы. */

/**Список modules - это модули, в которых компонент сможет искать код создания объектов.
 Методы могут быть с любым именем, главное - это их возвращаемые типы (NetworkUtils и DatabaseHelper).
 Они дают понять компоненту, какие именно объекты мы захотим от него получить. При компиляции, даггер
 проверит, в каком модуле какой объект можно достать и нагенерит в реализации двух этих методов
 соответствующий код создания этих объектов. А в MainActivity мы просто вызовем эти методы компонента,
 чтобы получить готовые объекты. */
@Component(modules = {StorageModule.class, NetworkModule.class,EventModule.class})
public interface AppComponent {
    //NetworkUtils getNetworkUtils();
    //DatabaseHelper getDatabaseHelper();


    /**У нас в MainActivity сейчас всего два объекта, которые мы получаем от компонента. Но если
     *  будет штук 20, то придется в интерфейсе компонента описать 20 get-методов и в коде MainActivity
     *  написать 20 вызовов этих методов. У даггера есть более удобное решение для таких случаев.
     *  Мы можем научить компонент не просто возвращать объекты, а самому наполнять Activity требуемыми
     *  объектами. Т.е. мы даем компоненту экземпляр MainActivity, а он смотрит, какие объекты нужны,
     *  создает их и сам помещает в соответствующие поля.Вместо пары get-методов мы описываем один
     *  inject-метод. Имя может быть любым, главное - это тип его единственного параметра. Мы указываем
     *  здесь MainActivity. Тем самым, мы говорим компоненту, что когда мы будем вызывать этот метод
     *  и передавать туда экземпляр MainActivity, мы ожидаем, что компонент наполнит этот экземпляр
     *  требуемыми объектами.При компиляции проекта, даггер увидит этот метод в интерфейсе,
     *  просмотрит класс MainActivity на наличие (помеченных специальными аннотациями) полей и
     *  определит, какие объекты ему нужно будет создавать. В итоге, в классе компонента даггер
     *  реализует метод injectsMainActivity так, чтобы он получал объекты из своих модулей и
     *  подставлял их в соответствующие переменные переданного ему экземпляра MainActivity. */
    void injectsMainActivity(MainActivity mainActivity);
}